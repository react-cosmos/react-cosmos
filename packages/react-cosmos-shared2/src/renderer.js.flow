// @flow

import type { FixtureState } from './fixtureState';

// FYI: Renderer ids are self assigned in remote environments, so uniqueness
// cannot be established by consensus
export type RendererId = string;

export type FixtureNames = string[];

export type RequestFixtureListMsg = {
  type: 'requestFixtureList'
};

export type SelectFixtureMsg = {
  type: 'selectFixture',
  payload: {
    rendererId: RendererId,
    // A null fixturePath means unselecting current fixture
    fixturePath: null | string
  }
};

export type SetFixtureStateMsg = {
  type: 'setFixtureState',
  payload: {
    rendererId: RendererId,
    // The fixture path is sent alongside the fixture state change to ensure
    // that the fixture state is only paired with its corresponding fixture
    fixturePath: string,
    fixtureStateChange: $Shape<FixtureState>
  }
};

export type RendererRequest =
  | RequestFixtureListMsg
  | SelectFixtureMsg
  | SetFixtureStateMsg;

export type OnRendererRequest = RendererRequest => mixed;

export type FixtureListMsg = {
  type: 'fixtureList',
  payload: {
    rendererId: RendererId,
    fixtures: FixtureNames
  }
};

// Caused by an organic state change inside the renderer. Also dispatched
// after a fixtureSelect request, when rendering stateful components, as their
// initial state is read.
export type FixtureStateChangeMsg = {
  type: 'fixtureStateChange',
  payload: {
    rendererId: RendererId,
    // The fixture path is sent alongside the fixture state to ensure that the
    // fixture state is only paired with its corresponding fixture
    fixturePath: string,
    // Entire fixture state is included
    fixtureState: FixtureState
  }
};

// Confirmation for a setFixtureState request, together with the entire
// resulting fixtureState.
export type FixtureStateSyncMsg = {
  type: 'fixtureStateSync',
  payload: {
    rendererId: RendererId,
    // The fixture path is sent alongside the fixture state to ensure that the
    // fixture state is only paired with its corresponding fixture
    fixturePath: string,
    // Entire fixture state is included
    fixtureState: FixtureState
  }
};

// Announce an error caught inside a renderer, which is useful when the
// renderer is remote or if it errors before dispatching `fixtureList`
// TODO: Integrate
// export type RendererErrorMsg = {
//   type: 'rendererError',
//   payload: {
//     rendererId: RendererId
//     // TODO: Including error payload might be useful for remotes which
//     // aren't running alongside renderers (eg. Browser UI with React Native
//     // renderer)
//   }
// };

export type RendererResponse =
  | FixtureListMsg
  | FixtureStateChangeMsg
  | FixtureStateSyncMsg;

export type OnRendererResponse = RendererResponse => mixed;

declare export var RENDERER_MESSAGE_EVENT_NAME: string;
